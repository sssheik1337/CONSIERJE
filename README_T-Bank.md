# Кассовая часть T‑Bank (эквайринг)

Этот документ описывает реализованные в проекте функции работы с API T‑Bank для оплат через СБП и картой: формирование платёжных запросов, генерацию подписи Token, обработку вебхуков и типичные точки отказа. Документация сфокусирована на кассовой части и не затрагивает бизнес‑логику бота.

## Технический обзор

* **Формирование Init** (`t_pay.init_payment`): собирает сумму, описание, PayType, Recurrent, NotificationURL и Receipt. В запрос добавляется Token, рассчитанный из корневых полей.
* **Получение QR** (`t_pay.get_qr`): отправляет `PaymentId`, `DataType` и `TerminalKey`, подписанные Token. Возвращает `Data` (готовый URL) и/или `RequestKey` для привязки счёта.
* **Проверка статуса** (`t_pay.get_payment_state` и хэндлер `/tbank_notify`): вебхук валидируется по Token и TerminalKey, статусы `AUTHORIZED`/`CONFIRMED` применяются к платежу, `ACTIVE` по RequestKey сохраняет `AccountToken`.
* **Подпись Token**: функция `_generate_token` использует корневые поля запроса, добавляет `Password` перед сортировкой, пропускает вложенные объекты и None, а булевые значения приводит к строкам `"true"/"false"` в нижнем регистре. Вебхуки проверяются через `compute_token` в `main.py`, где действует тот же формат.
* **Обработка вебхуков** (`main.tbank_notify`): логирует полезную нагрузку, сверяет подпись, сохраняет `AccountToken`, переводит оплату в `CONFIRMED` и продлевает подписку. Статус `ACTIVE` из GetAddAccountQrState/уведомлений фиксируется в таблице `sbp_links`.

## Алгоритм T‑Bank Token

1. Собрать только корневые пары `ключ:значение`, исключив `Token` и вложенные структуры (`dict`/`list`). В вебхуках также исключаются `Data/DATA/Receipt` по имени ключа.
2. Добавить пару `Password=...` **до сортировки**.
3. Отсортировать пары по ключу в алфавитном порядке.
4. Сконкатенировать только значения (преобразовать к строке). Все булевые значения приводятся к `"true"/"false"` в нижнем регистре. Несоответствие формату приводит к ошибке проверки подписи на стороне T‑Bank.
5. Вычислить `sha256` от строки и передать hex‑значение в поле `Token`.

| Правило                          | Верно                              | Неверно                        |
|----------------------------------|------------------------------------|--------------------------------|
| Пароль включается до сортировки  | добавлен в набор ключей            | добавлен после сортировки      |
| Исключение вложенных объектов    | пропущены `Data/Receipt` как dict   | вложенные dict попали в хэш    |
| Булевы                           | `true`/`false` (строки)            | Python `True`/`False`          |
| Поле `Token`                     | исключено                          | осталось в наборе              |
| Порядок ключей                   | сортировка по алфавиту             | исходный порядок               |

## Пример корректной подписи Init

```python
payload = {
    "Amount": 10000,
    "OrderId": "sbp_123_1_1700000000",
    "PayType": "O",
    "Recurrent": "Y",
    "NotificationURL": "https://example.ngrok.app/tbank_notify",
    "DATA": {"QR": "true"},
    "Receipt": {...},
    "TerminalKey": "1234567890",
}
# Token считают по корневым полям + Password, без DATA/Receipt
```

Пример ошибки: оставить `Token` в `payload` перед расчётом или сериализовать `DATA` в строку — подпись будет неверной.

## Разбор webhook `/tbank_notify`

1. Проверяется `TerminalKey` и опционально `X-Tbank-Secret`.
2. Пересчитывается Token по корневым полям уведомления (без `Token`, `Data/DATA/Receipt`, вложенных объектов; булевы → `true/false`).
3. Если `Status` ∈ {`CONFIRMED`, `AUTHORIZED`} — платеж помечается `CONFIRMED`, продлевается подписка на `months` из таблицы payments.
4. Если присутствует `AccountToken` или `RequestKey`, сохраняется в `sbp_links` и `users.account_token`, флаг `auto_renew` включается.
5. Статус `ACTIVE` из уведомлений/опроса `GetAddAccountQrState` фиксирует успешную привязку счёта.

## Логика оплаты картой

### 1) Разовый платёж картой (CIT)
* Инициация через `init_payment` с `CustomerKey`, `Recurrent="Y"`, `PayType="O"` и обязательным `Receipt`.
* Пользователь переходит на `PaymentURL` и подтверждает оплату на стороне T‑Bank.
* В webhook приходит `CONFIRMED`, статус платежа обновляется, подписка продлевается.

### 2) Привязка карты и рекуррентные платежи (MIT)
* В webhook сохраняются `CustomerKey` и `RebillId` для пользователя.
* Для автосписания используется рекуррентный `Init` с `OperationInitiatorType="R"`, `RebillId` и `CustomerKey`.
* После `Init` вызывается `finalize_rebill`: если статус `AUTHORIZED` и оплата двухстадийная, выполняется `Confirm`, иначе используется `GetState`.
* MIT‑списание выполняется методом `Charge`. Обязательно передаются `PaymentId` или `RebillId`, `Amount` и `Receipt`.
* `Receipt` должен быть полноценным чеком (Items, Taxation, Payments, Email и т. д.) и всегда формируется вручную на стороне сервера.

## Логика оплаты через СБП

### 1) Разовый платёж СБП
* Инициация через `init_payment` с `Recurrent="Y"` и `DATA={"QR":"true"}`.
* Далее получаем QR через `get_qr` и выдаём ссылку пользователю.
* В webhook приходит `CONFIRMED`, подписка продлевается.

### 2) Рекуррентные платежи СБП (AccountToken)
* `AccountToken` сохраняется из webhook.
* Для автосписания используется `ChargeQr` (через `charge_qr`/`charge_sbp_autopayment`).
* При успехе подписка продлевается, при ошибке автопродление отключается.

## Обязательность Receipt

* Receipt обязателен при оплате картой (Init), при оплате через СБП (Init), а также при всех MIT‑ребиллах.
* Receipt всегда формируется вручную на стороне сервера.
* Банк не генерирует чек самостоятельно и не корректирует Receipt.
* Отсутствие Receipt при включённой кассе приводит к ошибке:
  `ErrorCode 309 — {request.validate.expected.receipt}`.

## Пример Receipt для MIT‑списания по карте

```json
{
  "FfdVersion": "1.05",
  "Taxation": "usn_income",
  "Items": [
    {
      "Name": "Подписка",
      "Price": 10000,
      "Quantity": 1,
      "Amount": 10000,
      "PaymentMethod": "full_prepayment",
      "PaymentObject": "service",
      "Tax": "none"
    }
  ],
  "Payments": {"Electronic": 10000},
  "Email": "user@example.com"
}
```

## Подводные камни

* Все булевые значения в подписи Token должны быть приведены к `"true"/"false"` в нижнем регистре, иначе T‑Bank отклонит подпись.
* Нельзя включать поле `Token` при расчёте подписи и нельзя сериализовывать вложенные структуры (`DATA`, `Receipt`) в строку.
* Используйте правильный TerminalPassword: смешение боевого/тестового пароля приведёт к коду ошибки 401/403 или неверной подписи.
* Уведомления приходят с `NotificationType`; его игнорирование может скрыть отличие между платёжными и сервисными событиями.
* Логи следует маскировать чувствительные значения (пароли, токены) при публикации наружу.

## Минимальный чек‑лист подключения

1. Задать `T_PAY_BASE_URL`, `T_PAY_TERMINAL_KEY`, `T_PAY_PASSWORD`, `TINKOFF_NOTIFY_URL` в `.env`.
2. При Init передавать сумму в копейках, `PayType="O"`, `Recurrent="Y"`, `DATA={"QR":"true"}`, корректный `Receipt` с email/телефоном.
3. Генерировать Token строго по алгоритму выше, исключая вложенные объекты.
4. После Init вызвать `GetQr` и отдать пользователю `Data` или `RequestKey`.
5. Обработать вебхук: подтвердить подпись, зафиксировать `AccountToken`, присвоить статус `CONFIRMED`, продлить подписку и включить `auto_renew`.
6. Логировать запросы/ответы T‑Bank и периодически сверять подпись с контрольными примерами.

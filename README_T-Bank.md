# Кассовая часть T‑Bank (эквайринг)

Этот документ описывает реализованные в проекте функции работы с API T‑Bank для оплат через СБП: формирование платёжных запросов, генерацию подписи Token, обработку вебхуков и типичные точки отказа. Документация сфокусирована только на кассовой части и не затрагивает бизнес‑логику бота.

## Технический обзор

* **Формирование Init** (`t_pay.init_payment`): собирает сумму в копейках, описание, PayType, Recurrent, NotificationURL и Receipt (чек по ФФД 1.05 формируется автоматически, если не передан вручную). В запрос добавляется Token, рассчитанный из корневых полей.
* **Получение QR** (`t_pay.get_qr`): отправляет `PaymentId`, `DataType` и `TerminalKey`, подписанные Token. Возвращает `Data` (готовый URL) и/или `RequestKey` для привязки счёта.
* **Проверка статуса** (`t_pay.get_payment_state` и хэндлер `/tbank_notify`): вебхук валидируется по Token и TerminalKey, статусы `AUTHORIZED`/`CONFIRMED` применяются к платежу, `ACTIVE` по RequestKey сохраняет `AccountToken`.
* **Подпись Token**: функция `_generate_token` использует корневые поля запроса, добавляет `Password` перед сортировкой, пропускает вложенные объекты и None, но булевы значения превращает в строку `True/False` (см. раздел «Подводные камни»). Вебхуки проверяются через `compute_token` в `main.py`, где булевы приводятся к `true/false` и исключаются `Data/DATA/Receipt` по имени ключа.
* **Обработка вебхуков** (`main.tbank_notify`): логирует полезную нагрузку, сверяет подпись, сохраняет `AccountToken`, переводит оплату в `CONFIRMED` и продлевает подписку. Статус `ACTIVE` из GetAddAccountQrState/уведомлений фиксируется в таблице `sbp_links`.

## Алгоритм T‑Bank Token

1. Собрать только корневые пары `ключ:значение`, исключив `Token` и вложенные структуры (`dict`/`list`). В вебхуках также исключаются `Data/DATA/Receipt` по имени ключа.
2. Добавить пару `Password=...` **до сортировки**.
3. Отсортировать пары по ключу в алфавитном порядке.
4. Сконкатенировать только значения (преобразовать к строке). В вебхуке булевы переводятся в `"true"/"false"`; в исходящих запросах сейчас остаётся `"True"/"False"` — учитывайте это.
5. Вычислить `sha256` от строки и передать hex‑значение в поле `Token`.

| Правило                          | Верно                              | Неверно                        |
|----------------------------------|------------------------------------|--------------------------------|
| Пароль включается до сортировки  | добавлен в набор ключей            | добавлен после сортировки      |
| Исключение вложенных объектов    | пропущены `Data/Receipt` как dict   | вложенные dict попали в хэш    |
| Булевы                           | `true`/`false` (строки)            | Python `True`/`False`          |
| Поле `Token`                     | исключено                          | осталось в наборе              |
| Порядок ключей                   | сортировка по алфавиту             | исходный порядок               |

## Пример корректной подписи Init

```python
payload = {
    "Amount": 10000,
    "OrderId": "sbp_123_1_1700000000",
    "PayType": "O",
    "Recurrent": "Y",
    "NotificationURL": "https://example.ngrok.app/tbank_notify",
    "DATA": {"QR": "true"},
    "Receipt": {...},
    "TerminalKey": "1234567890",
}
# Token считают по корневым полям + Password, без DATA/Receipt
```

Пример ошибки: оставить `Token` в `payload` перед расчётом или сериализовать `DATA` в строку — подпись будет неверной.

## Разбор webhook `/tbank_notify`

1. Проверяется `TerminalKey` и опционально `X-Tbank-Secret`.
2. Пересчитывается Token по корневым полям уведомления (без `Token`, `Data/DATA/Receipt`, вложенных объектов; булевы → `true/false`).
3. Если `Status` ∈ {`CONFIRMED`, `AUTHORIZED`} — платеж помечается `CONFIRMED`, продлевается подписка на `months` из таблицы payments.
4. Если присутствует `AccountToken` или `RequestKey`, сохраняется в `sbp_links` и `users.account_token`, флаг `auto_renew` включается.
5. Статус `ACTIVE` из уведомлений/опроса `GetAddAccountQrState` фиксирует успешную привязку счёта.

## Подводные камни

* В `_generate_token` булевы значения превращаются в `True/False`, а не `true/false` — это может привести к расхождению подписи, если T‑Bank ожидает нижний регистр. В `compute_token` для вебхуков используется корректный формат.
* Нельзя включать поле `Token` при расчёте подписи и нельзя сериализовывать вложенные структуры (`DATA`, `Receipt`) в строку.
* Используйте правильный TerminalPassword: смешение боевого/тестового пароля приведёт к коду ошибки 401/403 или неверной подписи.
* Уведомления приходят с `NotificationType`; его игнорирование может скрыть отличие между платёжными и сервисными событиями.
* Логи следует маскировать чувствительные значения (пароли, токены) при публикации наружу.

## Минимальный чек‑лист подключения

1. Задать `T_PAY_BASE_URL`, `T_PAY_TERMINAL_KEY`, `T_PAY_PASSWORD`, `TINKOFF_NOTIFY_URL` в `.env`.
2. При Init передавать сумму в копейках, `PayType="O"`, `Recurrent="Y"`, `DATA={"QR":"true"}`, корректный `Receipt` с email/телефоном.
3. Генерировать Token строго по алгоритму выше, исключая вложенные объекты.
4. После Init вызвать `GetQr` и отдать пользователю `Data` или `RequestKey`.
5. Обработать вебхук: подтвердить подпись, зафиксировать `AccountToken`, присвоить статус `CONFIRMED`, продлить подписку и включить `auto_renew`.
6. Логировать запросы/ответы T‑Bank и периодически сверять подпись с контрольными примерами.

